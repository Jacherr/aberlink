\chapter{Implementation}

%The implementation should discuss any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third-party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?
%
%It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant?
%
%You can conclude this section by reviewing the end of the implementation stage against the planned requirements. 

\section{Code Implementation \& Third-Party libraries}
As seen below the Website and Discord bot have been split up into two separate sections because during implementation to help keep the systems separate. This helps with code maintainability, readability and allows the administrator who sets up this project to deploy the website and bot services on different containers or networks. For more information of third party libraries please see appendix A.

\subsection{Website Building and Final Design}
To create and run the website a set of libraries and Linux packages are used to perform certain tasks. Firstly, the Linux package Apache2 \cite{apache2} is used as the web hosting framework got the website along with the library libapache2-mod-auth-openidc to reroute all incoming traffic to OpenID Connect \cite{OpenID} for user authentication. On top of these the linux tool certbot \cite{certbot} is used to create a Let's Encrypt certificate for the website to enable HTTPS. 

As discussed previously in this document in section \ref{sec1:Research} there were many libraries that were considered when deciding on the website framework. Django \cite{Django} was the framework of choice and it is open-source and free to use on personal projects. It is also very useful as it generates the majority of the code required to create and run a website so most of the code used will be picked up by the system for UAP. Apart from the generated template, a "Django Application" called login that contains the files and code which is used to run the website. I can confirm that the folder, login, is all my own code and should not fall under UAP.

The website pages also use a third party library called bootstrap \cite{bootstrap} that is used to generate responsive mobile-first CSS for the website. The final design of the website ended up being very similar to that of the mockups made in section \ref{sec2:ui} and included below are some images from the final website.

\textbf{Note}: The navigation bars in the images below are smaller than the mockups due to the change in screen size. These images were taken on a 27inch monitor whereas the mockups were made for a 15inch monitor.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/website-acc-0.png}
	\caption{Final website with 0 linked Discord accounts}
	\label{fig:final-web-acc-0}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/website-acc-1.png}
	\caption{Final website with 1 linked Discord accounts}
	\label{fig:final-web-acc-1}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/website-acc-2.png}
	\caption{Final website with 2 linked Discord accounts}
	\label{fig:final-web-acc-2}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/website-admin-openidc.png}
	\caption{Final website Admin page for Aber accounts}
	\label{fig:final-web-admin-openidc}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/website-admin-discord.png}
	\caption{Final website Admin page for Discord accounts}
	\label{fig:final-web-admin-dis}
\end{figure}

\subsection{Discord Bot}
The Discord bot (AberLink) implementation is exactly as described in the section \ref{sec2:discord} of the design. AberLink uses the Python library Discord.py \cite{discord.py} to make calls to and from the Discord API and to interact with the database it uses the Python library Psycopg2 \cite{psycopg2}. Both of these pieces of software are open-source and free to use in personal projects. 

\subsubsection{Setup and Configuration}\label{sec3:discord-setup}
The bot contains a main file called AberLink.py that configures the bot giving it all the required permissions/settings to run. It loads the sensitive credentials from a .env file using the Python library dotenv \cite{dotenv}. This file contains key-value pairs that hold the Discord bot token that is accessible from the Discord developer portal \href{https://discord.com/developers/applications}{https://discord.com/developers/applications} and information required for the bot to connect to the database.

\begin{figure}[H]
	\begin{lstlisting}[language=Python]
# load the private discord token from .env file.
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
WEBSITE = os.getenv('WEBSITE_URL')

# Initialise the database connection
PostgreSQL.connect()

# Initialise the Bot object with an accessible help Command object
helpCommand = DefaultHelpCommand()

bot = commands.Bot(
    command_prefix="!",
    help_command=helpCommand,
    intents=discord.Intents.all(),
)

bot.run(TOKEN)
\end{lstlisting}
\caption{Snippet of code from AberLink.py main Discord bot file}
\label{fig:discord-main-file}
\end{figure}

As seen in the figure above the key value pair for the \verb|DISCORD_TOKEN| is loaded in from the file and then used at the end of the code extract to run the bot. In the middle we see in important section called \verb|commands.Bot| that tells the bot key information such as which prefix to use that determines how a command is called. E.g. \verb|!| means that a command is invoked using \verb|!<command_name>|, by changing this then the command is invoked using that prefix. It is also not limited to a single character so can be \verb|AberLink| and then command would be invoked using \verb|AberLink<command_name>|.

\subsubsection{Discord Command Example}

The bot creates commands that can be used in a Discord server using the Discord.py \cite{discord.py} library. Below is an example of the ping command that is used as a way to check that the bot is alive. Discord.py turns this Python function into a Discord command when the decorator \verb|@commands.command(aliases=['p'])| is used where the \verb|aliases=['p']| parameter indicates an alias that can be used to call the command. The function then starts a timer using time() and stops after the first message is sent, then the message is edited to include the latency taken to edit and modify the message. Included in this response is also information on the database such as the latency, polling status and response time.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
@commands.command(aliases=['p'])
async def ping(self, ctx: Context):
	"""
	Returns latency and response time of Discord and the database
	"""
	start_time = time()
	message = await ctx.send(f' pong `DWSP latency: {str(round(ctx.bot.latency * 1000))}ms`')
	end_time = time()
	db_latency = PostgreSQL.get_connection_latency()
	db_poll = PostgreSQL.get_polling_status()
	await message.edit(content=f' pong \n{emojis["discord"]} `DWSP latency: {str(round(ctx.bot.latency * 1000))}ms` ' +
    f'`Response time: {str(int((end_time - start_time) * 1000))}ms` \n' +
    f'{emojis["aberlink_database"]} `Database Polling status: {db_poll}` `Database latency: {db_latency}ms`')

\end{lstlisting}
\caption{Example of AberLink's ping command code}
\label{fig:discord-command-ping-code}
\end{figure}

The commands response is then sent to the Discord channel with a response that looks similar to the one pictured below.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/discord-ping-command.png}
	\caption{Example of ping command in Discord}
	\label{fig:discord-command-ping}
\end{figure}

\subsubsection{How do I access a list of the commands in AberLink?}
The Discord.py library contains a useful function called \verb|DefaultHelpCommand()| that will generate an automatic list of commands available in your program by analysing each function that has the command decorator \verb|@commands.command()|. The list of commands is then accessible through Discord using the command prefix plus the keyword help which in this case would be !help. Below is an example of the current output from the help command at time of this screenshot.  

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/discord-help.png}
	\caption{Example of Discord help command to display list of Discord commands for AberLink}
	\label{fig:discord-help}
\end{figure}

\subsubsection{Database}
The Discord bot uses the Python library psycopg2 \cite{psycopg2} to connect remotely to the PostgreSQL \cite{psql} database using a file located inside of the \verb|AberLinkDiscord/cogs| folder called \verb|db.py|.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
CONN = 0

def connect():
"""
Connects or reconnects to database
"""
load_dotenv(find_dotenv())
DB_NAME = os.getenv('DATABASE_NAME')
DB_USER = os.getenv('USER')
DB_PASSWORD = os.getenv('PASSWORD')
DB_HOST = os.getenv('HOST')
DB_PORT = os.getenv('PORT')

try:
	global CONN
	CONN = psycopg2.connect(database=DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)
	print(f'Reconnected to PSQL database: {CONN}')
except psycopg2.OperationalError as err:
	print(f'Error connecting to database. Error: {err}')
	raise
\end{lstlisting}
\caption{Extract of the connection function to the PostgreSQL database from the AberLink Discord bot}
\label{fig:discord-database}
\end{figure}

As seen in the code extract above it uses the same functions as described in section \ref{sec3:discord-setup} for loading data from the \verb|.env|. Once it has loaded in the correct key value pairs it then attempts to connect to the database using the function \verb|connect()| and then print the output to the command line. If this is not the case e.g. database is down then then the try except statement catches the error and prints it out to the command line. If the database connection is successful however the information about that connection is then stored in a global variable called CONN which stands for connection.

To ensure that the connection will always be restored if there is a catastrophic failure a function was added that attempts to get a cursor on the database and if it fails then it calls the function above \ref{fig:discord-database}. This function \verb|try_connection()| is called by any piece of code that relies on extracting information from the database to ensure that there will never be a database error.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
def try_connection():
	"""
	Attempts to get a cursor from the database otherwise it restarts the database connection
	"""
	try:
		cur = CONN.cursor()
	except psycopg2.InterfaceError:
		PostgreSQL.connect()
\end{lstlisting}
\caption{Extract of the try connection function for connecting to the database from the Discord bot}
\label{fig:discord-database-try-connect}
\end{figure}

Once a connection is established with the database and connection issues are handled then SQL queries can be made on the database to get information. In Discord there are only really two functions that are required to read information on a student; a function to lookup a students Discord account using their Discord ID and a function to lookup a students Aber OpenID Connect information using their username. Both of these functions are relatively similar so only one has been included to illustrate how this works.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
def get_discord_user(discord_id: int):
""" 
Returns a discord user if they exist or None
"""
PostgreSQL.try_connection()
cur = CONN.cursor()

cur.execute(f"SELECT * FROM login_discorduser WHERE id={discord_id}")
row = cur.fetchone()
if row is not None:
	return {"id": row[0], "last_login": row[1], "openidc_id": row[2]}
\end{lstlisting}
\caption{SQL function used to get information on a Discord user from the database in the Discord bot}
\label{fig:discord-database-sql-statement}
\end{figure}

As seen above a parameter of the Discord ID is passed to the function which then gets a database connection using the \verb|try_connect()| as previously described in the last section and executes an SQL statement on the database. The first record is then fetched from the database and is then returned as a JSON object to allow for it to be easily accessed. If there are no records that match then None is returned.

\subsubsection{Verification}
This command is used to verify users accounts. It begins by trying to find the verified role on the server, then using the function above in figure \ref{fig:discord-database-sql-statement} to get the users information. The function then checks that the user exists and then uses another SQL lookup to get information on the OpenID Connect \cite{OpenID} Aber account. Once these requests have been completed the user is given the role of \verb|verified| followed by the message "You are now verified with AberLink". If the feature discussed in section \ref{sec3:server-config} to allow automatic nicknames is enabled then the bot will also change the users nickname.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
@commands.bot_has_permissions(manage_nicknames=True, manage_roles=True)
@commands.command(aliases=['v'])
async def verify(self, ctx: Context):
	"""
	Confirms if user is verified or not
	"""
	verified = await check_verify_role(ctx)
	db_discord_user = await check_discord_user(ctx)
	if verified is None or db_discord_user is None:
		return
	db_openid_user = PostgreSQL.get_openid_user(db_discord_user["openidc_id"])
	email = db_openid_user["username"]
	user = ctx.message.author
	await user.add_roles(verified, reason='Assigning user the verified role')
	await ctx.send("You are now verified with AberLink")

	if check_shelve_file(ctx.guild):
        await user.edit(nick=f'{user.name} [{email}]', reason="Changing users\'s nickname")
\end{lstlisting}
\caption{Discord command to verify students}
\label{fig:discord-verify-cmd}
\end{figure}

\subsubsection{Attendance}

\begin{figure}[H]
\begin{lstlisting}[language=Python]
@commands.command(aliases=['h'])
async def here(self, ctx: Context):
	"""
	Marks the student as present in the practical
	"""
	await ctx.message.delete()
	dm_channel = await ctx.author.create_dm()
	discord_user = PostgreSQL.get_discord_user(ctx.author.id)
	url = 'https://integration.aber.ac.uk/joa38/submit.php'

	# Gets openid user from Discord id
	if discord_user is None:
		await dm_channel.send(f'You have not been verified yet. Please visit {WEBSITE} to get verified')
		return
	openid_user = PostgreSQL.get_openid_user(discord_user["openidc_id"])

	# getting request from API endpoint
	data = {'username': openid_user["username"]}
	api_response = requests.post(url, json=data).json()

	# If evaluates to true send user message with timestamp
	if eval(api_response["status_updated"].title()):
		current_time = datetime.now()
		current_time = current_time.strftime("%d/%m/%Y %H:%M:%S")
		await dm_channel.send(f'Your attendance in the server `{ctx.guild.name}` has been recorded for the module: `{api_response["module_code"]}` with timestamp: `{current_time}`')
	else:
		await dm_channel.send('Your attendance has not been recorded for this practical. If you believe this is incorrect please contact your module coordinator.')
\end{lstlisting}
\caption{Discord command to mark students attendance}
\label{fig:discord-here-cmd}
\end{figure}

\subsubsection{Error handling}
Discord.py includes a decorator called \verb|@Bot.event()| that goes inside of the AberLink.py file for dealing with bot events. This paired with a function called \verb|on_command_error()| deals with error messages. Below is an example of some of the if statements that deal with bot errors. The final else if command to check if the command is not found is extremely important as it tells the bot to ignore any commands that does not exist in the case where two Discord bots use the same command prefix but have different commands.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
if isinstance(error, commands.errors.CheckFailure):
	await ctx.send(error)
elif isinstance(error, commands.errors.MissingRequiredArgument):
	await ctx.send('You are missing a required argument.')
elif isinstance(error, commands.errors.CommandNotFound):
	pass
\end{lstlisting}
\caption{Example of AberLink's on\_command\_error() checking statements}
\label{fig:discord-error-checking}
\end{figure}

\subsubsection{Server Configurations}\label{sec3:server-config}
AberLink contains a feature called autoSetNickname that will automatically assign nicknames to users when they join or verify on the server by appending their aber username to the end of their name. e.g. JoelinRome\#4893 becomes JoelinRome [joa38]. This was added to help lecturers easily identify which student is which and if the student is uncomfortable with this they can always manually change it back. 

Some lecturers might not enjoy this feature and prefer to turn it off so included is a micro database using the python module \cite{shelve} that creates a file stored in the same directory as the Python file. This basically creates a file that can be accessed at any time and acts as persistent storage. It contains key value pairs e.g. \verb|{server_id : true}| that store a boolean on whether the automatic naming feature is enabled or disabled. 

\subsection{Database}\label{sec3:database}
The Database implementation was relatively straight forward as Django \cite{Django} generates all of the required tables for the project to function once you define the models. I've included the model used to generate OpenID Connect \cite{OpenID} aber user model below. In this figure you can see that there are two classes; OpenIDCUserManager to create a new database object and OpenIDCUser to make the database model. 

The OpenIDCUserManager class has three main parameters; one to call itself, a user which is a JSON object and password which is defaulted to None as no password data is stored. The information from the user object is passed throughout the code and is used to decide if the user should have admin permissions. The user is then saved to the database.

The OpenIDCUser class contains a nested class called usertypes that is a list of all the possible choices for incoming usertypes from user authentication. Further down we can see that there is a set of definitions for the database model such as the id, username, name, etc. Note however that the usertype definition uses the choices class to define what role a user may have. As this model is the main model used to authenticate users on the website Django requires that the model contains a few special items including a password which I have set to None and the arrays at the bottom called USERNAME\_FIELD and REQUIRED\_FIELDS.

\begin{figure}[H]
\begin{lstlisting}[language=Python]
class OpenIDCUserManager(BaseUserManager):
    def create_user(self, user, password=None):
        new_user = self.model(
            username = user['OIDC_CLAIM_preferred_username'],
            name = user['OIDC_CLAIM_name'],
            email = user['OIDC_CLAIM_email'],
            usertype = user['OIDC_CLAIM_usertype']
        )
        if user['OIDC_CLAIM_usertype'] == "staff":
            new_user.is_admin = True
        new_user.save(using=self._db)
        return new_user

class OpenIDCUser(AbstractBaseUser):
    objects = OpenIDCUserManager()

    class usertypes(models.TextChoices):
        STAFF = 'staff'
        UNDERGRAD = 'undergrad'
        POSTGRAD = 'postgrad'
        OFFICE = 'office'
        CONTED = 'conted'
        SUMMER = 'summer'
        WEB = 'web'
        TEMPORARY = 'temporary'
        UNKNOWN = 'unknown'

    id = models.AutoField(auto_created=True, primary_key=True, serialize=False)
    username = models.CharField(max_length=40)
    name = models.CharField(max_length=300)
    email = models.CharField(max_length=30)
    usertype = models.CharField(max_length=50, choices=usertypes.choices)
    last_login = models.DateTimeField(null=True)
    password = None
    is_active = models.BooleanField(default=True)
    is_admin = models.BooleanField(default=False)

    USERNAME_FIELD = 'id'
    REQUIRED_FIELDS = ['username', 'name', 'email', 'usertype']
\end{lstlisting}
\caption{Django database model of OpenID Connect Aber users}
\label{fig:django-database-code}
\end{figure}

The tables generated for the database are pictured below and they do differ quite drastically from the tables discussed during the design section \ref{sec2:database} of this document. This is because I was not originally accounting for the tables that get automatically generated by Django \cite{Django} that are required for the application to run. Below the figure is information to explain what the Django generated tables mean.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/er-diagram.png}
	\caption{Final Entity Relationship diagram for database}
	\label{fig:final-database}
\end{figure}

\begin{itemize}
	\item \textbf{User tables} - These two tables are the ones that have been discussed previously in this document for storing user data.
	\begin{itemize}
		\item \textbf{login\_openidcuser} - This table stores the OpenID Connect \cite{OpenID} information and is used as the authenticated user account.
		\item \textbf{login\_discorduser} - This table stores information on the discord user and contains a foreign key relationship with the table above.
	\end{itemize}
	\item \textbf{Django tables} - Tables generated by Django \cite{Django}
	\begin{itemize}
		\item \textbf{django\_migrations} - This table contains the history of the changes made to the database using Django. It acts as a way to revert to previous versions of the database in the case of 
		errors.
		\item \textbf{django\_session} - Stores sessions on the currently logged in users.
		\item \textbf{django\_content\_type} - Stores information on all available models in the database.
		\item \textbf{django\_admin\_log} - Stores history of logins for administrative users.
		\item \textbf{auth\_group \& auth\_group\_permissions \& auth\_permissions} - These tables are part of the backend for the authentication of users.
	\end{itemize}
\end{itemize}

Below are examples of the records that are stored in the database tables. 

\textbf{Note}: The column last\_login in the table \ref{tab:aber-table} contains the word datetime but should have a datetime object as seen in table \ref{tab:dis-table}. It has been removed so that the table fits nicely in this document.

\begin{table}[H]
	\centering
	\small
	\setlength\tabcolsep{2pt}
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		\underline{id} & username & name & email & usertype & last\_login & is\_active & is\_admin \\
		\hline
		1 & joa38 & Joel Adams & joa38@aber.ac.uk & staff & datetime & t & t \\
		2 & jet39 & Jenny Thyer & jet39@aber.ac.uk & student & datetime & t & f \\
		3 & maw86 & Michael Antony West & maw86@aber.ac.uk & student & datetime & t & f \\
		\hline 
	\end{tabular}
	\caption{Aberystwyth user table example}
	\label{tab:aber-table}
\end{table}

\begin{table}[H]
	\centering
	\small
	\setlength\tabcolsep{2pt}
	\begin{tabular}{|c|c|c|}
		\hline
		\underline{id}                 & last\_login                   & openidc\_id* \\
		\hline
		727834884915331144 & 2021-02-18 16:43:47.067328+00 & 1           \\
		284352754321719296 & 2021-02-18 16:43:47.067328+00 & 1           \\
		246998944964542464 & 2021-02-04 11:14:40.057891+00 & 2           \\
		282248714955784192 & 2021-02-12 17:35:23.044226+00 & 3           \\
		\hline
	\end{tabular}
	\caption{Discord user table example}
	\label{tab:dis-table}
\end{table}

\section{Configuration and Setup}
After completion of this project there is a plan to setup this service permanently for the department so a folder was created called \textit{config} containing information on how to set up this project. This folder contains a README.md file that explains how and what is needed to be configured to get the system up and running properly. it also contains a bash script called setup.sh that installs and the relevant dependencies and sets up the virtual environments for the projects. Also included are a few example configuration files for Apache2 \cite{apache2}, Django \cite{Django}, OpenID Connect authentication \cite{OpenID} and Discord.py \cite{discord.py}.

\section{Unforeseen Issues}\label{sec3:unforeseen}
An issue that was encountered was with creating the custom user model in Django that would have been used to model the database. The documentation and videos found online about implementing user models were rather cryptic and difficult to understand, however after much research a video explaining how to implement a good custom user model was found that resolved the issues. Once this was completed I realised that Django is not happy with modelling the primary key of a table using a char so switched over to using an int. This turned out to be a good idea as Aberystwyth university tends to recycle old emails so over the next 5 years there could be an issue where the database would try and create a new entry in the database with the same email.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{Figures/database-er-1}
	\caption{Updated Entity relationship diagram for database}
	\label{fig:database-er-1}
\end{figure}

\section{Review}
\subsection{Review Against Planned Requirements}\label{sec3:pr}
Most of the planned requirements have not changed during implementation however some of the promised tasks have only been partially fulfilled. Please see Appendix \ref{tab:fr-test} for a table of the functional requirements specified in \ref{sec1:fr}. For more information on requirements that did not pass please see \ref{sec4:fr}.

In the final section of section \ref{sec1:obj} \textbf{Further potential work} I have decided against integrating DemoHelper into AberLink as this would greatly increase its complexity and make it much more difficult to maintain. Welsh language support has also not been implemented as I do not speak the language nor understand it well enough.

\subsection{Review Against Project Process}\label{sec3:pp}

Below is included a table describing the iterations and what was completed each one. These iterations were based on the list of objectives created in section \ref{sec1:obj} and span over the course of two months. For more detail please see the wordpress blog here \href{https://cs39440blog.wordpress.com/}{https://cs39440blog.wordpress.com/}.

\begin{longtable}[H]{| c | c | p{9cm} |}
\hline
Iteration & Time taken (days) & What happened? \\
\hline
1 & 5 & Research into services required to run the project and basic setup of uni container. Lots of meetings to discuss what data can be used/stored and began setup of API endpoint for attendance. \\
\hline
2 & 5 & Setup HTTPS on container, installed Django \cite{Django} and created basic website using it. Linked up Django to database and created basic Discord login system. \\
\hline
3 & 5 & Added OpenID Connect \cite{OpenID} to website for aber user login. Created basic models to link OpenID accounts to Discord accounts in PostgreSQL \cite{psql}. \\
\hline
4 & 7 & Created Admin pages and implemented proper database model for Discord and Aber users\\
\hline
5 & 5 & Created Discord bot skeleton and added support for it to connect to the database.\\
\hline
6 & 5 & Added attendance and verification to Discord bot. \\
\hline
7 & 5 & Added content to main webpage and option to delete a Discord account or all data. Added custom error message webpages for 400, 403, 404 and 500. \\
\hline
8 & 5 & Updated main user page so that it queries Discord API to get profile picture and username and update webpage with details. Added more features to Discord bot to interact with database.\\
\hline
9 & 5 & Created Configuration folder for installing the software along with bash script to install dependencies.\\
\hline
10 & 5 & Added Discord bot functionality to add configurations to a server and feature to automatically change Discord users nickname to append aber email.\\
\hline
11 & 16 & Working on LaTeX document for project report. \\
\hline
\caption{Project iterations and what occurred}
\label{tab:project-iterations}
\end{longtable}

Included is a graph of my GitLab commits over time below to help backup my table described above. 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Figures/gitlab-commit-graph.png}
	\caption{GitLab graph of commits over time}
	\label{fig:gitlab-graph}
\end{figure}